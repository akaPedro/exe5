<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Cubo com TRIANGLE_STRIP</title>
  <style>canvas { width: 600px; height: 600px; }</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

if (!gl) {
  alert("WebGL não suportado");
}

// Vertex Shader
const vsSource = `
  attribute vec3 aPosition;
  attribute vec3 aColor;
  varying vec3 vColor;
  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;
  void main(void) {
    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
    vColor = aColor;
  }
`;

// Fragment Shader
const fsSource = `
  precision mediump float;
  varying vec3 vColor;
  void main(void) {
    gl_FragColor = vec4(vColor, 1.0);
  }
`;

// Compilar shaders
function compileShader(src, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    alert(gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}

const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);

// Programa de shader
const shaderProgram = gl.createProgram();
gl.attachShader(shaderProgram, vertexShader);
gl.attachShader(shaderProgram, fragmentShader);
gl.linkProgram(shaderProgram);
gl.useProgram(shaderProgram);

// Localizações
const aPosition = gl.getAttribLocation(shaderProgram, "aPosition");
const aColor = gl.getAttribLocation(shaderProgram, "aColor");
const uModelViewMatrix = gl.getUniformLocation(shaderProgram, "uModelViewMatrix");
const uProjectionMatrix = gl.getUniformLocation(shaderProgram, "uProjectionMatrix");

// Dados do cubo por face usando TRIANGLE_STRIP
const faces = [
  // Frente (vermelho)
  {
    color: [1, 0, 0],
    vertices: [
      -1, -1,  1,
       1, -1,  1,
      -1,  1,  1,
       1,  1,  1
    ]
  },
  // Trás (verde)
  {
    color: [0, 1, 0],
    vertices: [
      1, -1, -1,
     -1, -1, -1,
      1,  1, -1,
     -1,  1, -1
    ]
  },
  // Direita (amarelo)
  {
    color: [1, 1, 0],
    vertices: [
      1, -1,  1,
      1, -1, -1,
      1,  1,  1,
      1,  1, -1
    ]
  },
  // Esquerda (azul)
  {
    color: [0, 0, 1],
    vertices: [
     -1, -1, -1,
     -1, -1,  1,
     -1,  1, -1,
     -1,  1,  1
    ]
  },
  // Topo (ciano)
  {
    color: [0, 1, 1],
    vertices: [
     -1, 1,  1,
      1, 1,  1,
     -1, 1, -1,
      1, 1, -1
    ]
  },
  // Base (magenta)
  {
    color: [1, 0, 1],
    vertices: [
     -1, -1, -1,
      1, -1, -1,
     -1, -1,  1,
      1, -1,  1
    ]
  }
];

// Criar buffers
const positionBuffer = gl.createBuffer();
const colorBuffer = gl.createBuffer();

// Matriz utilitária
const mat4 = {
  create: () => new Float32Array([1, 0, 0, 0,
                                  0, 1, 0, 0,
                                  0, 0, 1, 0,
                                  0, 0, 0, 1]),
  translate: (out, a, v) => {
    out[12] = a[12] + v[0];
    out[13] = a[13] + v[1];
    out[14] = a[14] + v[2];
  },
  rotateY: (out, a, rad) => {
    const s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c; out[2] = -s;
    out[8] = s; out[10] = c;
  }
};

// Projeção
function getProjectionMatrix(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov / 2);
  return new Float32Array([
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far+near)/(near-far), -1,
    0, 0, (2*far*near)/(near-far), 0
  ]);
}

// Desenhar cena
function drawScene() {
  gl.clearColor(0.1, 0.1, 0.1, 1.0);
  gl.enable(gl.DEPTH_TEST);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const aspect = canvas.clientWidth / canvas.clientHeight;
  const projection = getProjectionMatrix(Math.PI / 4, aspect, 0.1, 100.0);
  const modelView = mat4.create();
  mat4.translate(modelView, modelView, [0, 0, -6]);
  mat4.rotateY(modelView, modelView, performance.now() / 1000);

  gl.uniformMatrix4fv(uProjectionMatrix, false, projection);
  gl.uniformMatrix4fv(uModelViewMatrix, false, modelView);

  // Desenhar cada face com TRIANGLE_STRIP
  for (const face of faces) {
    const positions = new Float32Array(face.vertices);
    const colors = new Float32Array([
      ...face.color, ...face.color,
      ...face.color, ...face.color
    ]);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aPosition);

    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aColor);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  requestAnimationFrame(drawScene);
}

drawScene();
</script>
</body>
</html>

